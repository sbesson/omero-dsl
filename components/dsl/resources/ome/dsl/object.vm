##
##  Copyright (c) 2007 Glencoe Software Inc. All rights reserved.
##  Use is subject to license terms supplied in LICENSE.txt
##
##
##  SETUP
##
#set($ofilter = "${type.table}_owner_filter")
#set($gfilter = "${type.table}_group_filter")
#set($efilter = "${type.table}_event_filter")
#set($pfilter = "${type.table}_perms_filter")
#set($cascadeEjb = "javax.persistence.CascadeType.MERGE,")
#set($cascadeEjb = "$cascadeEjb javax.persistence.CascadeType.PERSIST,")
#set($cascadeEjb = "$cascadeEjb javax.persistence.CascadeType.REFRESH")
#set($cascadeHib = "org.hibernate.annotations.CascadeType.LOCK,")
#set($cascadeHib = "$cascadeHib org.hibernate.annotations.CascadeType.MERGE,")
#set($cascadeHib = "$cascadeHib org.hibernate.annotations.CascadeType.PERSIST,")
#set($cascadeHib = "$cascadeHib org.hibernate.annotations.CascadeType.REPLICATE,")
#set($cascadeHib = "$cascadeHib org.hibernate.annotations.CascadeType.REFRESH,")
#set($cascadeHib = "$cascadeHib org.hibernate.annotations.CascadeType.SAVE_UPDATE,")
#set($cascadeHib = "$cascadeHib org.hibernate.annotations.CascadeType.EVICT")
##
##
##
##
/*
 *   This file was generated by dsl/resources/ome/dsl/object.vm
 * 
 *   Copyright (c) 2007 Glencoe Software Inc. All rights reserved.
 *   Use is subject to license terms supplied in LICENSE.txt
 *
 */

package ${type.package};

import ome.conditions.*;
import ome.model.*;

#if(!$type.superclass && !$type.global)
/**
 * These filter definitions are used by the security system
 * to eliminate non-readable objects from queries. The regular
 * user does not need to worry about them, as they will be
 * injected directly into the SQL (not HQL)
 */
@org.hibernate.annotations.FilterDefs({
    @org.hibernate.annotations.FilterDef(name="${ofilter}", 
        parameters=@org.hibernate.annotations.ParamDef( name="ownerId", type="java.lang.Long" )),
    @org.hibernate.annotations.FilterDef(name="${gfilter}",
        parameters=@org.hibernate.annotations.ParamDef( name="groupId", type="java.lang.Long" )),
    @org.hibernate.annotations.FilterDef(name="${efilter}",
        parameters=@org.hibernate.annotations.ParamDef( name="eventId", type="java.lang.Long" )),
    @org.hibernate.annotations.FilterDef(name="${pfilter}",
        parameters=@org.hibernate.annotations.ParamDef( name="permsStr", type="java.lang.String" ))#foreach( $prop in $type.classProperties )#if($prop.one2Many),
    @org.hibernate.annotations.FilterDef(name="${ofilter}_${prop.nameUpper}",
        parameters=@org.hibernate.annotations.ParamDef( name="ownerId", type="java.lang.Long" )),
    @org.hibernate.annotations.FilterDef(name="${gfilter}_${prop.nameUpper}",
        parameters=@org.hibernate.annotations.ParamDef( name="groupId", type="java.lang.Long" )),
    @org.hibernate.annotations.FilterDef(name="${efilter}_${prop.nameUpper}",
        parameters=@org.hibernate.annotations.ParamDef( name="eventId", type="java.lang.Long" )),
    @org.hibernate.annotations.FilterDef(name="${pfilter}_${prop.nameUpper}",
        parameters=@org.hibernate.annotations.ParamDef( name="permsStr", type="java.lang.String" ))
#end
#end
})
##if(!$type.superclass)
#if(!$type.global)
@org.hibernate.annotations.Filters({
    // See the comments on filters above
    @org.hibernate.annotations.Filter(name="${ofilter}", condition=":ownerId = owner_id"),
    @org.hibernate.annotations.Filter(name="${gfilter}", condition=":groupId = group_id"),
    @org.hibernate.annotations.Filter(name="${efilter}", condition=":eventId = event_id"),
    @org.hibernate.annotations.Filter(name="${pfilter}", condition=":permsStr = permissions"),
    @org.hibernate.annotations.Filter(name="securityFilter")
})
#end
#end
@javax.persistence.Entity
##
## Determine inheritance type
##
###############################################################
#if($type.superclass)
## JOINED SUBCLASS
#set($superId = ${type.typeToColumn($type.superclass)} )
#if(!$type.discriminator)
@javax.persistence.PrimaryKeyJoinColumn(name="${superId}_id") 
@javax.persistence.Table(name = "${type.table}")
@org.hibernate.annotations.ForeignKey(name="FK${type.table}_${superId}_id_${superId}")
#else
## SINGLETABLE SUBCLASS
@javax.persistence.DiscriminatorValue("${type.discriminator}") 
#end
#else##########################################################
## TOP OF HIERARCHY
@javax.persistence.Table(name = "${type.table}")
@org.hibernate.annotations.Entity( selectBeforeUpdate = true )
#if(!$type.discriminator)
## ...OF JOINED TABLES
@javax.persistence.Inheritance(strategy=javax.persistence.InheritanceType.JOINED)
#else
## ... IN A SINGLE TABLE
@javax.persistence.Inheritance(strategy=javax.persistence.InheritanceType.SINGLE_TABLE)
@javax.persistence.DiscriminatorValue("${type.discriminator}") 
@javax.persistence.DiscriminatorColumn( 
    name="discriminator", discriminatorType=javax.persistence.DiscriminatorType.STRING 
)
#end
@javax.persistence.SequenceGenerator( 
    name="seq_${type.table}", 
    sequenceName="seq_${type.table}" 
) 
#end############################################################
//TODO@org.hibernate.search.annotations.Indexed(index="FullText")
@org.hibernate.search.annotations.ClassBridge(
    name="details", 
    impl = ome.util.DetailsFieldBridge.class,
    index=org.hibernate.search.annotations.Index.UN_TOKENIZED, 
    store=org.hibernate.search.annotations.Store.NO
)
public #if($type.abstract)abstract#end class ${type.shortname}
#if($type.superclass)extends $type.superclass #end
implements java.io.Serializable, IObject#if(!$type.immutable), IMutable#end#if($type.isEnum), IEnum#end#if($type.isLink), ILink#end#if($type.annotated), IAnnotated#end
{

   /* These values are defined in dsl/resources/ome/dsl/mapping.vm:
    * -------------------------------------------------------------
    * Explanation of serialVersionUID ex 0000000 03 00 00 01 03 01 L;
    * 1-7   : currently unused
    * 8-9   : major part (3.x.x)
    * 10-11 : minor part (x.0.x)
    * 12-13 : patch part (x.x.0)
    * 14-15 : release type   (B)
    * 16-17 : release number (3)
    * 18-19 : increment per delta // any changes to the dsl or mapping files
    */
    private static final long serialVersionUID = 0000000030000020301L;
    
#if(!$type.global)
   /*
    * Constants naming filters used by the OMERO
    * security system.
    */
    public final static String OWNER_FILTER = "${ofilter}";
    public final static String GROUP_FILTER = "${gfilter}";
    public final static String EVENT_FILTER = "${efilter}";
    public final static String PERMS_FILTER = "${pfilter}";
#end

    public ${type.shortname} () {
        this(null, true);
    }

    protected ${type.shortname} (Long id) {
        this(id, true);
    }

    /**
     * Main constructor.
     */
    public ${type.shortname} (Long id, boolean loaded) {
#if($type.superclass)
        super(id, loaded);
#else
        setId(id);
        if (loaded) {
            getDetails().setContext(this);
        } else {
            if (this.id == null) {
                throw new ApiUsageException("Id cannot be null for a proxy");
            }
            unload();
        }
#end
    }

#if($type.isEnum)
    public ${type.shortname} (String value) {
        this(null, true);
        setValue(value);
    }
#end

## (1) Check if needed
#if($type.requiredSingleProperties.size() > 0 && !$type.isEnum)
    public ${type.shortname}(
##
## Add ctor arguments, with a comma if not the first
##
#set($comma = "")
#foreach($prop in $type.requiredSingleProperties)$comma${prop.fieldType} _${prop.name}#set($comma = ",")#end
    ) {
        this(null, true);
#foreach($prop in $type.requiredSingleProperties)
        set${prop.nameCapped}(_${prop.name});
#end
    }
#end## END ctorWithRequiredNeeded

#if(!${type.superclass})
    public final static String ID = "${type.id}_id";
    
    protected Long id;

   /**
    * The DB unique identifier for this object. You are not responsible for
    * setting the id; however, it can be useful for creating "unloaded"
    * versions of your objects.
    *
    * Each top-level entity contains an id field of type long.
    * For all objects returned from the server, this value will
    * be non-null, which doesn't necessarily hold for the other
    * fields.
    */
    @javax.persistence.Id
    @javax.persistence.GeneratedValue(
        strategy=javax.persistence.GenerationType.SEQUENCE,
        generator="seq_${type.table}") 
    @org.hibernate.search.annotations.DocumentId
    public Long getId() {
        return this.id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public final static String DETAILS = "${type.id}_details";

   /**
    * Note: subclasses of this class can only return subclasses of 
    * this {@link Details} type.
    */
   protected Details details = new Details();

   /**
    * The details of this object correspond to low-level system
    * information. Owner, permissions, Details is always guaranteed 
    * to be non-null, unless the user actively nulls it.
    *
    * Every entity also contains a Detail reference, which doesn't
    * refer to a separate table but rather to a collection of fields
    * collected into a Hibernate "component" which is embedded in the
    * object.
    *
    * HQL queries which refer to the Details component cannot directly
    * fetch the entity like this:
    *
    *    select o from Object join fetch o.details
    *
    * but rather each field of the Details instance must be explicitly
    * joined:
    *
    *    select o from Object join fetch o.details.owner
    *
    * It should also be noted that not all types have all the fields
    * which are present on Details. For example,
    *
    *    select e from Experimenter e join fetch e.details.owner
    *
    * will fail. Experimenter has no owner, for obvious reasons.
    */
    @javax.persistence.Embedded
    @org.hibernate.annotations.Target(Details.class)
    public ome.model.internal.Details getDetails() {
        preGetter( DETAILS );
        return this.details;
    }

   /**
    * Use the {@link Details\#copy(Details)} or {@link Details\#shallowCopy(Details)}
    * methods to set the {@link Details} instance instead.
    */
    protected void setDetails(ome.model.internal.Details details) {
        preSetter( DETAILS, details );
        this.details = (Details) details;
    }

#end

   /*
    *    INTERFACE-BASED
    *    Several properties are defined by whether or not
    *    the OME definition has certain interfaces.
    */

#if(!${type.immutable} && !${type.superclass})
    public final static String VERSION = "${type.id}_version";

    protected Integer version = 0; // TODO?

   /**
    * This version number is controlled by the database for optimisitic
    * locking.
    */
    @javax.persistence.Column(name="version") 
    // @javax.persistence.Version 
//TODO mark off #118 if this succeeds, otherwise, completely remove versions and test updateEvent
    public Integer getVersion() {
        preGetter( VERSION );
        return this.version;
    }

    public void setVersion(Integer version) {
        preSetter( VERSION, version );
        this.version = version;
    }

#end

#if($type.named)
    
    public final static String NAME = "${type.id}_name";
    
    protected String name;
 
    @javax.persistence.Column( nullable = false, length = 256, name = "name")
    public String getName() {
        preGetter( NAME );
        return this.name;
    }

    public void setName(String name) {
        preSetter( NAME, name );
        this.name = name;
    }
#end## type.named

#if($type.described)
    
    public final static String DESCRIPTION = "${type.id}_description";
    
    protected String description;
 
    @javax.persistence.Column( nullable = true, length = 256, name = "description")
    public String getDescription() {
        preGetter( DESCRIPTION );
        return this.description;
    }

    public void setDescription(String description) {
        preSetter( DESCRIPTION, description );
        this.description = description;
    }
#end## type.described

   /*
    *    PROPERTIES
    *    All properties which follow are straight-forward
    *    and can be understood using only the Hibernate
    *    documentation.
    */

#foreach($prop in $type.classProperties)#######################################EACH
##
##  Now we iterate throug each of the properties and based on the type we 
##  generate the appropriate methods.
##
##
## SETUP
##
## Property to be used only within the property loop which is guaranteed to be reset
## This is used only for one-to-many (collection-valued) relationships
## If this is a link, cascadeHibCollection will be reset to all-delete-orphan
#set( $cascadeHibCollection = ${cascadeHib} )
##
#if( $prop.isLink )
#set( $LinkType = ${prop.type} )
#set( $Link = ${prop.shortType} )
#set( $ElementType = ${prop.target})
#set( $Element = ${prop.shortTarget})
##
#if($prop.class.name == "ome.dsl.ChildLink" )
#set( $order = "this, addition" )
#set( $next = "parent" )
#set( $other = "child" )
#set( $cascadeHibCollection = "org.hibernate.annotations.CascadeType.ALL, org.hibernate.annotations.CascadeType.DELETE_ORPHAN" )
#elseif($prop.class.name == "ome.dsl.ParentLink")
#set( $order = "addition, this" )
#set( $next = "child" )
#set( $other = "parent" )
#set( $cascadeHibCollection = "org.hibernate.annotations.CascadeType.ALL, org.hibernate.annotations.CascadeType.DELETE_ORPHAN" )
#end
#end##isLink
##
    protected ${prop.fieldType} ${prop.name} = ${prop.fieldInitializer};

#if($prop.class.name == "ome.dsl.EntryField")#############################TYPE
##
##  EntryFields are handled by ome/dsl/data.vm, since each of the entries isn't
##  a real property but rather an enum value for the database. However, they 
##  are not even returned by $type.classProperties only $type.properties
##
#elseif($prop.one2Many)###################################################TYPE
##
##
#if(!${type.global})
   /*
    * Filter names which are used by the security system to turn on filters
    * for this particular collection.
    */
    public final static String OWNER_FILTER_${prop.nameUpper} = "${ofilter}_${prop.nameUpper}";
    public final static String GROUP_FILTER_${prop.nameUpper} = "${gfilter}_${prop.nameUpper}";
    public final static String EVENT_FILTER_${prop.nameUpper} = "${efilter}_${prop.nameUpper}";
    public final static String PERMS_FILTER_${prop.nameUpper} = "${pfilter}_${prop.nameUpper}";
#end

   /**
    * returns ${prop.name} . You should not modify this collection unless you
    * know what you are doing. Use the iterate method instead.
    *
##
#if($prop.ordered)
    * one-to-many List ${type.id}.${prop.name} (${prop.type})
    * Values are indexed by the column "index" on ${prop.type}
    */
    @javax.persistence.JoinColumn(name="${prop.inverse}", nullable=false)
    @javax.persistence.OneToMany(fetch=javax.persistence.FetchType.LAZY, cascade={${cascadeEjb}})
    @org.hibernate.annotations.IndexColumn(name="index", nullable=false)
#else
    * one-to-many Set ${type.id}.${prop.name} (${prop.type})
    */
    @javax.persistence.OneToMany(mappedBy="${prop.inverse}", fetch=javax.persistence.FetchType.LAZY, cascade={${cascadeEjb}})
#end
    @org.hibernate.annotations.Cascade({${cascadeHibCollection}})
##
##
#if(!$type.global)
## TODO Can these be set on list 
    @org.hibernate.annotations.Filters({
        @org.hibernate.annotations.Filter(name="securityFilter"),
        @org.hibernate.annotations.Filter(name=OWNER_FILTER_${prop.nameUpper}, condition=":ownerId = owner_id"),
        @org.hibernate.annotations.Filter(name=GROUP_FILTER_${prop.nameUpper}, condition=":groupId = group_id"),
        @org.hibernate.annotations.Filter(name=EVENT_FILTER_${prop.nameUpper}, condition=":eventId = event_id"),
        @org.hibernate.annotations.Filter(name=PERMS_FILTER_${prop.nameUpper}, condition=":permsStr = permissions")
    })
#end
    protected ${prop.fieldType} get${prop.nameCapped}() {
        preGetter( ${prop.nameUpper} );
        return this.${prop.name};
    }

    /**
     * setter for ${prop.name} should be avoided. Does not fulfill normal semantics.
     */
    protected void set${prop.nameCapped}(${prop.fieldType} ${prop.name}) {
        preSetter( ${prop.nameUpper}, ${prop.name} );
        this.${prop.name} = ${prop.name};
    }
##
##  A one-to-many property represents a set that is contained by this entity.
##  These methods represent our handling of Hibernate's "inverse" sets
##  which do not act as expected with regards to getters & setters.
##
##  To prevent users from making mistakes like not properly setting both 
##  sides of a relationship, these fields are hidden, and only accessible via
##  the following methods. Methods fall into several categories: 
##    (A) general   
##    (B) list-only
##    (C) link-based
##
##  (A) General one-to-many code
##  ----------------------------
##
    /**
     * returns the size of ${prop.name}. If less than zero, the Set was null.
     */
    public int sizeOf${prop.nameCapped}() {
        preGetter( ${prop.nameUpper} );
        return this.${prop.name} == null ? -1 : this.${prop.name}.size();
    }

    /**
     * should be used rather than accessing the ${prop.name} set directly.
     * This method will never return null, but rather will return an instance
     * of {@link ome.util.EmptyIterator}. To test for a null collection,
     * see of {@link #sizeOf${prop.nameCapped}()} is less than zero.
     */
    public java.util.Iterator<${prop.type}> iterate${prop.nameCapped}() {
        preGetter( ${prop.nameUpper} );
        if ( get${prop.nameCapped}() == null ) {
            return new ome.util.EmptyIterator<${prop.type}>();
        }
        return get${prop.nameCapped}().iterator(); // TODO should this be direct access
    }

    /**
     * Returns an unmodifiable collection-view 
     */
    public java.util.Collection<${prop.type}> unmodifiable${prop.nameCapped}() {
        preGetter( ${prop.nameUpper} );
        if ( get${prop.nameCapped}() == null ) {
            return java.util.Collections.emptyList();
        }
        return java.util.Collections.unmodifiableCollection( get${prop.nameCapped}() );
    }
    
    /**
     * takes a CBlock and calls the block once for each ${prop.type} while
     * collecting the results. If <code>block == null</code>, then the
     * iterator values themselves are collected. This method uses
     * {@link #iterate${prop.nameCapped}} internally and so will return a value
     * even if the underlying collection is null.
     */
    @SuppressWarnings("unchecked")
    public <E> java.util.List<E> collect${prop.nameCapped}(ome.util.CBlock<E> block) {

        preGetter( ${prop.nameUpper} );

        java.util.List<E> result = new java.util.ArrayList<E>();
        java.util.Iterator<${prop.type}> it = iterate${prop.nameCapped}();
        while ( it.hasNext() ) {
            IObject obj = (IObject) it.next();
            if ( block != null ) {
                result.add( block.call( obj ) );
            } else {
                result.add( (E) obj );
            }
        }
        return result;
    }

    /**
     * use instead of set${prop.nameCapped} . Makes the necessary
     * call on ${prop.type} as well.
     */
    public void add${prop.shortType}(${prop.type} target) {
        preSetter( ${prop.nameUpper}, target );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        get${prop.nameCapped}().add( target );
        // If this relationship is not ordered, then we will 
        // "attempt" the setting even if it is loaded.
        if (target.isLoaded() || !${prop.ordered} ) {
            target.set${prop.inverseCapped} ( this );
       }
    }

    /**
     * use like add${prop.shortType}.
     */
    public void add${prop.shortType}Set(java.util.Collection<${prop.type}> targets) {
        preSetter( ${prop.nameUpper}, targets );
        if (get${prop.nameCapped}() == null) {
           throwNullCollectionException("${prop.nameCapped}");
        }
        get${prop.nameCapped}().addAll( targets );
        java.util.Iterator<${prop.type}> it = targets.iterator();
        while ( it.hasNext() ) {
            ${prop.type} target = it.next();
            // If this relationship is not ordered, then we will 
            // "attempt" the setting even if it is loaded.
            if (target.isLoaded() || !${prop.ordered} ) {
                target.set${prop.inverseCapped} ( this );
            }
        }
    }

    /**
     * removes a single element from this set and makes the inverse call on ${prop.type}
     */
    public void remove${prop.shortType}(${prop.type} target) {
        preSetter( ${prop.nameUpper}, target );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        get${prop.nameCapped}().remove( target );
        if (target.isLoaded() || !${prop.ordered} ) {
            target.set${prop.inverseCapped} ( null );
        }
    }

    /**
     * use like remove${prop.shortType}
     */
    public void remove${prop.shortType}Set(java.util.Collection<${prop.type}> targets ) {
        preSetter( ${prop.nameUpper}, targets );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        get${prop.nameCapped}().removeAll( targets );
        java.util.Iterator<${prop.type}> it = targets.iterator();
        while ( it.hasNext() ) {
            ${prop.type} target = it.next();
            if (target.isLoaded() || !${prop.ordered} ) {
                target.set${prop.inverseCapped} ( null );
            }
        }
    }

##
## The following methods are overwritten separately by the link code (C) below
## and therefore are omitted here if this is a link property.
##
#if(!${prop.isLink})
    /**
     * clears the set.
     */
    public void clear${prop.nameCapped}() {
        preSetter( ${prop.nameUpper}, null );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        get${prop.nameCapped}().clear();
        java.util.Iterator<${prop.type}> it = iterate${prop.nameCapped}();
        while (it.hasNext()) {
            ${prop.type} target = it.next();
            target.set${prop.inverseCapped} ( null );
        }
    }
#end## End not link


##
##  (B) List-based code
##  -------------------
##
#if( ${prop.ordered} )
    /**
     * Gets the ${prop.type} at the given index.
     */
    public ${prop.type} get${prop.shortType}(int index)
    throws IndexOutOfBoundsException {
        preGetter( ${prop.nameUpper} );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        return get${prop.nameCapped}().get(index);
    }

    /**
     * Sets the ${prop.type} at the given index. Adheres to the {@link List\#set(int ,E))}
     * contract. To extend the list, use {@link #add${prop.shortType}()}.
     * @see java.util.List\#set(int, E)
     */
    public void set${prop.shortType}(int index, ${prop.type} element) 
    throws IndexOutOfBoundsException {
        preSetter( ${prop.nameUpper}, index );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        get${prop.nameCapped}().set(index, element);
    }

    /**
     * Gets the first element of ${prop.name} which can be interpreted as the
     * primary or default element in some situations. If there is not first
     * element, an {@link IndexOutOfBoundsException} is throws. This method
     * will also throw an {@link ApiUsageException} if the collection is
     * unloaded. See {@link #sizeOf${prop.nameCapped}()} for more information.
     */
    @javax.persistence.Transient
    public ${prop.type} getPrimary${prop.shortType}()
    throws IndexOutOfBoundsException {
        preGetter( ${prop.nameUpper} );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        return get${prop.nameCapped}().get(0);
    }
    

    /**
     * Swaps the first element of ${prop.name} with the first instance of the 
     * given element. If the given element is not in the list, an 
     * {@link IndexOutBoundException} will be thrown. Returns the swapped 
     * element. This method
     * will also throw an {@link ApiUsageException} if the collection is
     * unloaded. See {@link #sizeOf${prop.nameCapped}()} for more information.
     */
    public ${prop.type} setPrimary${prop.shortType}(${prop.type} element)
    throws IndexOutOfBoundsException {
        preGetter( ${prop.nameUpper} );
        if (get${prop.nameCapped}() == null) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        ${prop.fieldType} list = get${prop.nameCapped}();
        int index = list.indexOf(element);
        ${prop.type} old = list.get(0);
        list.set(index, old);
        list.set(0, element);
        return old;
    }
    
    
## TODO 
## ListIterator<${prop.type}> listIterator${prop.nameCapped}()
## public int indexOf(${prop.type} elt)
## public int lastIndexOf(${prop.type} elt) 
## List<${prop.type}> subList${prop.nameCapped}}(int fromIndex, int toIndex)
#end
##
##
##  (C) Link-based code
##  -------------------
##
##  These methods are like the set methods above, but help to completely
##  hide the link implementations.
##
#if( $prop.isLink )

    /**
     * Adds a ${LinkType} to ${prop.name} . This entails changing our ${prop.name} Set,
     * creating a new ${LinkType} and calling link${Element} on the ${ElementType}.
     */
    public ${LinkType} link${Element} (${ElementType} addition) {
        preSetter( ${prop.nameUpper}, addition );

        // Setup link
        ${LinkType} link = new ${LinkType}();
        link.link( ${order} );

        // Add it to us and possibly the other side.
        add${Link}( link, true );
        return link;
    }

    /**
     * Adds a ${LinkType} to ${prop.name}, allowing for recursion -- whether
     * or not add${prop.shortType} will be called on the addition <b>if it is loaded</b>
     */
    public void add${Link} (${LinkType} link, boolean bothSides) {
        preSetter( ${prop.nameUpper}, link );
        if ( get${prop.nameCapped}() == null ) {
            throwNullCollectionException("${prop.nameCapped}");
        }
        get${prop.nameCapped}().add( link );

#if(${prop.bidirectional})
        if ( bothSides && link.${other}().isLoaded() ) {
            link.${other}().add${Link}( link, false );
        }
#end
    }

    /**
     * provides an iterator over the ${next} values of the ${prop.name}. Like
     * with most Collection iterators, modificiations to the underlying collection
     * while iterating will result in an {@link ConcurrentModificationException}.
     * Use {@link #linked${Element}List()} instead.
     */
     public java.util.Iterator<${ElementType}> linked${Element}Iterator() {
        preGetter( ${prop.nameUpper} );
        if ( get${prop.nameCapped}() == null ) {
            return new ome.util.EmptyIterator<${ElementType}>();
        }

        final java.util.Iterator<${LinkType}> it = get${prop.nameCapped}().iterator();
        return new java.util.Iterator<${ElementType}>() {

            public boolean hasNext() {
                return it == null ? false : it.hasNext();
            }

            public ${ElementType} next() {
                if ( it == null ) {
                    throw new java.util.NoSuchElementException( "${prop.name} is null; no elements." );
                }
                ${LinkType} link = (${LinkType}) it.next();
                return link.${other}();
            }

            public void remove() {
                throw new UnsupportedOperationException("Cannot call remove on this iterator.");
            }

        };
    }

    /**
     * find all ${LinkType} which have the argument as their ${other}.
     */
    public java.util.Set<${LinkType}> find${Link}( ${ElementType} target ) {
        preGetter( ${prop.nameUpper} );

        final java.util.Iterator<${LinkType}> it = iterate${prop.nameCapped}();
        final java.util.Set<${LinkType}> result = new java.util.HashSet<${LinkType}>();
        while ( it.hasNext() ) {
            ${LinkType} link = it.next();
            if ( link.${other}() == target ) {
                result.add( link );
            }
        }
        return result;
    }

    /** 
     * produces a {@link List}-copy of the underlying collection. Unlike,
     * {@link #linked${Element}Iterator()}, while using the returned {@link List},
     * modifications can be made to the underlying collection without throwing
     * {@link ConcurrentModificationExceptions}
     */
    public java.util.List<${ElementType}> linked${Element}List() {
        preGetter( ${prop.nameUpper} );

        java.util.Iterator<${ElementType}> it = linked${Element}Iterator();
        java.util.List<${ElementType}> list = new java.util.ArrayList<${ElementType}>();

        while ( it.hasNext() ) {
            list.add( it.next() );
        }
        return list;
    }

    /**
     * takes a CBlock and calls the block once for each ${ElementType} while
     * collecting the results. If <code>block == null</code>, then the
     * iterator values themselves are collected.
     */
    @SuppressWarnings("unchecked")
    public <E> java.util.List<E> eachLinked${Element}(ome.util.CBlock<E> block) {
        preGetter( ${prop.nameUpper} );

        java.util.List<E> result = new java.util.ArrayList<E>();
        java.util.Iterator<${ElementType}> it = linked${Element}Iterator();
        while ( it.hasNext() ) {
            ${ElementType} obj = it.next();
            if ( block != null ) {
                result.add( block.call( obj ) );
            } else {
                result.add( (E) obj );
            }
        }
        return result;
    }

    /**
     * unlinks all ${ElementType} instances from this instance.
     */
    public void unlink${Element} (${ElementType} removal) {
        preSetter( ${prop.nameUpper}, removal );

        java.util.Set<${LinkType}> toRemove = find${Link}( removal );
        java.util.Iterator<${LinkType}> it = toRemove.iterator();
        while ( it.hasNext() ) {
            remove${Link}( it.next(), true );
        }
    }

    /**
     * removes the given ${Link} from ${prop.name}, allowing for recursion -- whether
     * or not the removal will call unlink${type.shortname} again <b>if loaded</b>.
     */
    public void remove${Link} (${LinkType} link, boolean bothSides) {
        preSetter( ${prop.nameUpper}, link );

        if ( get${prop.nameCapped}() == null ) {
            throwNullCollectionException("${prop.nameCapped}");
        }

        get${prop.nameCapped}().remove( link );

#if(${prop.bidirectional})
        if ( bothSides && link.${other}().isLoaded() ) {
            link.${other}().remove${Link}( link, false );
        }
#end
    }

    /**
     * clears the set.
     */
    public void clear${Element}Links() {
        preSetter( ${prop.nameUpper}, null );

        java.util.List<${LinkType}> list = new java.util.ArrayList<${LinkType}>( get${prop.nameCapped}() );
        for (${LinkType} link : list) {
            remove${Link}( link, true );
        }
    }
#end## End isLink
#elseif($prop.foreignKey)## REGULAR M-1 ##################################TYPE
   /**
    * Many-to-one field ${type.id}.${prop.name} (${prop.type})
    */
    @javax.persistence.ManyToOne(fetch = javax.persistence.FetchType.LAZY, cascade = {${cascadeEjb}}, targetEntity = ${prop.type}.class)
    @org.hibernate.annotations.Cascade({${cascadeHib}})
    @javax.persistence.JoinColumn(name="${prop.name}", nullable=${prop.nullable}, 
        unique=${prop.unique}, insertable=${prop.insert}, updatable=${prop.update})
    @org.hibernate.annotations.ForeignKey(name="FK${type.shortname.toLowerCase()}_${prop.name}_${prop.shortType.toLowerCase()}")
#if($type.isLink)## Need to convert from IObject to an implementation class
    @org.hibernate.annotations.Target(${prop.type}.class)
#end
    public ${prop.fieldType} get${prop.nameCapped}() {
        preGetter( ${prop.nameUpper} );
        return this.${prop.name};
    }

    public void set${prop.nameCapped}(${prop.fieldType} ${prop.name}) {
        preSetter( ${prop.nameUpper}, ${prop.name} );
        this.${prop.name} = ${prop.name};
    }
#else## REGULAR PROPERTY #################################################TYPE
   /**
    * Simple field ${type.id}.${prop.name} (${prop.type}) 
    */
    ${prop.typeAnnotation}
#if($prop.type == "java.lang.String")
    @org.hibernate.search.annotations.Fields({
        @org.hibernate.search.annotations.Field(index = org.hibernate.search.annotations.Index.TOKENIZED),
        @org.hibernate.search.annotations.Field(index = org.hibernate.search.annotations.Index.TOKENIZED, 
            name="combined_fields")
    })
#elseif($prop.type == "java.sql.Timestamp")
    @org.hibernate.search.annotations.DateBridge(
        resolution=org.hibernate.search.annotations.Resolution.MINUTE)
    @org.hibernate.search.annotations.Fields({
        @org.hibernate.search.annotations.Field(index = org.hibernate.search.annotations.Index.UN_TOKENIZED),
        @org.hibernate.search.annotations.Field(index = org.hibernate.search.annotations.Index.UN_TOKENIZED,
            name = "combined_fields")
    })
#else
    // Not indexed
#end
    @javax.persistence.Column(columnDefinition="${prop.def}", nullable=${prop.nullable}, unique=${prop.unique}, name="${prop.name}", updatable=${prop.update})
    public ${prop.fieldType} get${prop.nameCapped}() {
        preGetter( ${prop.nameUpper} );
        return this.${prop.name};
    }

    public void set${prop.nameCapped}(${prop.fieldType} ${prop.name}) {
        preSetter( ${prop.nameUpper}, ${prop.name});
        this.${prop.name} = (${prop.type}) ${prop.name};
    }
#end######################################################################TYPE
#end########################################################################EACH

    @javax.persistence.Transient
    // TODO what does this look like with Validator
    public boolean isValid() {
        return ome.util.Validator.validate(this).isValid();
    }
  
    public ome.util.Validation validate() {
        return ome.util.Validator.validate(this);
    }

#if(!$type.abstract)
## TODO trying to return type and not superclass
## but javassist in hibernate has problems with covariant return types
## http://jboss.org/index.html?module=bb&op=viewtopic&t=83199
## http://www.jboss.org/index.html?module=bb&op=viewtopic&p=3950680
##
    public ${type.id} newInstance() 
    {
        return new ${type.id}();
    }

    public ${type.id} proxy() {
        return new ${type.id}(this.id, false);
    }
#end

    @SuppressWarnings("unchecked")
    public boolean acceptFilter(ome.util.Filter __filter){
#if(!$type.superclass)
        this.id = (Long) __filter.filter(ID, this.id);
        this.details = (Details) __filter.filter(DETAILS, this.details);
#end
#if(!${type.immutable} && !${type.superclass})
        this.version = (Integer) __filter.filter(VERSION, this.version);
#end
#if($type.named)
        this.name = (String) __filter.filter(NAME, this.name);
#end
#if($type.described)
        this.description = (String) __filter.filter(DESCRIPTION, this.description);
#end
#foreach($prop in $type.classProperties)
        this.${prop.name} = (${prop.fieldType}) __filter.filter(${prop.name.toUpperCase()}, this.${prop.name} ); 
#end
#if($type.superclass)
        return super.acceptFilter(__filter);
#else
        return true;
#end
    }

    @Override
    public String toString(){
        String name = this.getClass().getName();
        StringBuilder sb = new StringBuilder(name.length() + 24);
        sb.append(name);
        if (this.id == null) {
            sb.append(":Hash_");
            sb.append(this.hashCode()); 
        } else {
            sb.append(":Id_");
            sb.append(this.id);
        }
        return sb.toString();
    }
  
    // FIELD-FIELDS
  
    public java.util.Set<String> fields() {
        return ${type.id}.FIELDS;
    }
  
#foreach($prop in $type.classProperties)
    public final static String ${prop.nameUpper} = "${type.id}_${prop.name}";
#end

    public final static java.util.Set<String> FIELDS;
    static {
       java.util.Set<String> raw = new java.util.HashSet<String>();
#if(!$type.superclass)
       raw.add(ID);
       raw.add(DETAILS);
#end
#if(!${type.immutable} && !${type.superclass})
       raw.add(VERSION);
#end
#if($type.named)
       raw.add(NAME);
#end
#if($type.described)
       raw.add(DESCRIPTION);
#end
#foreach($prop in $type.classProperties)
       raw.add(${prop.nameUpper});
#if($type.superclass)
       raw.addAll(${type.superclass}.FIELDS);
#end       
#end
       FIELDS = java.util.Collections.unmodifiableSet( raw );
    }
    
    
    // Dynamic Getter/Setter
#if(!$type.superclass)
    // TODO is this searched for proxies?
    @javax.persistence.Transient
    protected java.util.Map<String, Object> _dynamicFields; 

#end
    public Object retrieve(String field) {
        if (field == null) {
            return null;
#if(!$type.superclass)
        } else if (field.equals(ID)) {
             return getId();
        } else if (field.equals(DETAILS)) {
             return getDetails();
#end
#if(!${type.immutable} && !${type.superclass})
        } else if (field.equals(VERSION)) {
             return getVersion();
#end
#if($type.named)
        } else if (field.equals(NAME)) {
             return getName();
#end
#if($type.described)
        } else if (field.equals(DESCRIPTION)) {
             return getDescription();
#end
#foreach($prop in $type.classProperties)
        } else if (field.equals(${prop.nameUpper})) { // TODO use == here first??
            return get${prop.nameCapped}();
#end
        } else {
#if($type.superclass)
            return super.retrieve(field);
#else
            if (_dynamicFields != null) {
                return _dynamicFields.get(field);
            }
            return null;
#end            
        }
    }
    
    @SuppressWarnings("unchecked")
    public void putAt(String field, Object value)
    {
        if (field == null) {
            return;
#if(!$type.superclass)
        } else if (field.equals(ID)) {
             setId((Long) value);
        } else if (field.equals(DETAILS)) {
             setDetails((Details) value);
#end
#if(!${type.immutable} && !${type.superclass})
        } else if (field.equals(VERSION)) {
             setVersion((Integer) value);
#end
#if($type.named)
        } else if (field.equals(NAME)) {
             setName((String)value);
#end
#if($type.described)
        } else if (field.equals(DESCRIPTION)) {
             setDescription((String)value);
#end
#foreach($prop in $type.classProperties)
        } else if (field.equals(${prop.nameUpper})) {
            set${prop.nameCapped}((${prop.fieldType})value);
#end
        } else {
#if($type.superclass)
            super.putAt(field,value);
#else            
            if (_dynamicFields == null) {
                _dynamicFields = new java.util.HashMap<String, Object>();
            }
            _dynamicFields.put(field,value);
#end            
        }
    }

#if(!$type.superclass)
    @javax.persistence.Transient
    protected boolean _loaded = true;

    @javax.persistence.Transient
    public boolean isLoaded() {
        return _loaded;
    }

    protected void errorIfUnloaded() {
        if ( ! _loaded ) {
            throw new IllegalStateException("Object unloaded:"+this);
        }
    }
    
#end
    
    public void unload() {
        _loaded = false;
#if(!$type.superclass)
        this.details = null;
#end
#if(!${type.immutable} && !${type.superclass})
        this.version = null;
#end
#if($type.named)
        this.name = null;
#end
#if($type.described)
        this.description = null;
#end
#foreach($prop in $type.classProperties)
        this.${prop.name} = null;
#end
#if($type.superclass)
        super.unload();
#end
    }
    
#if(!$type.superclass)
    @javax.persistence.Transient
    private transient ome.model.internal.GraphHolder _graphHolder;
    
    @javax.persistence.Transient
    public final ome.model.internal.GraphHolder getGraphHolder()
    {
        if (_graphHolder == null)
            _graphHolder = new ome.model.internal.GraphHolder();
        return _graphHolder;
    }
#end

#*
    // SERIALIZATION
    /** the serialVersionID constant is set by objects.vm */
    private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException
    {
        s.defaultReadObject();  
    }
*#
    protected void preGetter( String field ) {
        errorIfUnloaded();
    }

    protected void preSetter( String field, Object value ) {
        errorIfUnloaded();
    }

    protected void throwNullCollectionException(String propertyName) {
        throw new ApiUsageException(
            "Error updating collection:" + propertyName +"\n"+
            "Collection is currently null. This can be seen\n"+
            "by testing \"sizeOf"+ propertyName +" < 0\". This implies\n"+
            "that this collection was unloaded. Please refresh this object\n"+
            "in order to update this collection.\n"
            );
    }

#######################################################
##
## Link Type Property code
##
#if( $type.class.name.equals("ome.dsl.LinkType"))
#foreach( $prop in $type.classProperties)
#if($prop.class.name == "ome.dsl.LinkParent")
#set( $parent = ${prop.type} )
#elseif($prop.class.name == "ome.dsl.LinkChild")
#set( $child = ${prop.type} )
#end
#end
    public void link($parent parent, $child child) {
        setParent( parent );
        setChild( child );
    }

    public $parent parent() {
        return ($parent) getParent();
    }

    public $child child() {
        return ($child) getChild();
    }
    
#end
##
#######################################################

#if(!$type.superclass)
    public static class Details extends ome.model.internal.Details {

        private final static long serialVersionUID = 0000000030000020301L;

        public ome.model.internal.Details newInstance() {
            return new Details();
        }
        
        @javax.persistence.Embedded
        public ome.model.internal.Permissions getPermissions() {
            return super.getPermissions();
        }

        @javax.persistence.ManyToOne(fetch = javax.persistence.FetchType.LAZY, cascade = {${cascadeEjb}})
        @org.hibernate.annotations.Cascade({${cascadeHib}})
        @javax.persistence.JoinColumn(name = "external_id", nullable = true, unique = true, insertable = true, updatable = false)
        @org.hibernate.annotations.ForeignKey(name = "FK${type.table}_external_id_externalinfo")
        public ome.model.meta.ExternalInfo getExternalInfo() {
            return super.getExternalInfo();
        }

#if(!$type.global)
        @Override
        @javax.persistence.ManyToOne(fetch = javax.persistence.FetchType.LAZY, cascade = {${cascadeEjb}})
        @org.hibernate.annotations.Cascade({${cascadeHib}})
        @javax.persistence.JoinColumn(name = "owner_id", nullable = false, unique = false, insertable = true, updatable = true)
        @org.hibernate.annotations.ForeignKey(name = "FK${type.table}_owner_id_experimenter")
        public ome.model.meta.Experimenter getOwner() {
            return super.getOwner();
        }

        @Override
        @javax.persistence.ManyToOne(fetch = javax.persistence.FetchType.LAZY, cascade = {${cascadeEjb}})
        @org.hibernate.annotations.Cascade({${cascadeHib}})
        @javax.persistence.JoinColumn(name = "creation_id", nullable = false, unique = false, insertable = true, updatable = false)
        @org.hibernate.annotations.ForeignKey(name = "FK${type.table}_creation_id_event")
        public ome.model.meta.Event getCreationEvent() {
            return super.getCreationEvent();
        }

        @Override
        @javax.persistence.ManyToOne(fetch = javax.persistence.FetchType.LAZY, cascade = {${cascadeEjb}})
        @org.hibernate.annotations.Cascade({${cascadeHib}})
        @javax.persistence.JoinColumn(name = "group_id", nullable = false, unique = false, insertable = true, updatable = true)
        @org.hibernate.annotations.ForeignKey(name = "FK${type.table}_group_id_experimentergroup")
        public ome.model.meta.ExperimenterGroup getGroup() {
            return super.getGroup();
        }

#if(!$type.immutable)
        @Override
        @javax.persistence.ManyToOne(fetch = javax.persistence.FetchType.LAZY, cascade = {${cascadeEjb}})
        @org.hibernate.annotations.Cascade({${cascadeHib}})
        @javax.persistence.JoinColumn(name = "update_id", nullable = false, unique = false, insertable = true, updatable = true)
        @org.hibernate.annotations.ForeignKey(name = "FK${type.table}_update_id_event")
        public ome.model.meta.Event getUpdateEvent() {
            return super.getUpdateEvent();
        }
#else
       /**
        * Overrides {@link ome.model.internal.Details#getUpdateEvent()} to
        * always return null.
        */
        @Override
        @javax.persistence.Transient
        public ome.model.meta.Event getUpdateEvent() {
            return null;
        }

       /**
        * Overrides {@link ome.model.internal.Details#setUpdateEvent(ome.model.meta.Event)} to
        * do nothing.
        */
        @Override
        public void setUpdateEvent(ome.model.meta.Event event) {
            // do nothing
        }
       
#end
#end

#if($extra)
$extra
#end

    }
#end
}